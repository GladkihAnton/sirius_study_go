Напишите функцию schedule(), которая запускает регулярное выполнение задачи:

Принимает на входе интервал времени dur и функцию fn.
Возвращает функцию отмены cancel.
После запуска каждые dur времени выполняет fn.
Если клиент вызвал cancel() — перестает выполнять fn.

```go
// schedule запускает регулярное выполнение функции с указанным интервалом.
// Возвращает функцию отмены. После отмены функция больше не выполняется.
func schedule(dur time.Duration, fn func()) func() {
    // ...
}

func main() {
    work := func() {
        at := time.Now()
        fmt.Printf("%s: work done\n", at.Format("15:04:05.000"))
    }

    cancel := schedule(50*time.Millisecond, work)
    defer cancel()

    // хватит на 5 тиков
    time.Sleep(260 * time.Millisecond)
}

```

Если функция fn медленная (выполняется дольше dur), то выполнения не должны «накапливаться». Если на момент очередного запуска предыдущая fn еще не завершилась, выполнение должно быть пропущено.

Клиент может вызвать cancel() несколько раз (но только из одной горутины, одновременные вызовы поддерживать не требуется). Отмена должна произойти по первому вызову, при повторных не должно быть паники.

Отмена должна быть мгновенной: горутина, запущенная внутри schedule(), должна завершиться сразу после вызова cancel(), а не спустя время.

- T: + (достаточно только goleak)
- B: -